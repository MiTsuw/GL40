/*!
\page page1 Introduction generale
*********************************
Le programme d'optimisation repond au cahier des charges suivant :
-# ../doc_specifications/<fichier>

Les algorithmes sont presentes dans le document de conception generale :
- ../doc_conception_generale/<aplication.tex>

Le programme d'optimisation est accessible via les classes exportees ConfigParams et Application.
Les fonctions d'optimisation sont specifiees par configuration des parametres d'execution de la classe ConfigParams.
L'execution est lancee par appel de la fonction principale de calcul de la classe Application.

Les configurations et modes de fonctionnement sont explicites dans la section \ref page2.

Cinq modes d'execution sont fournis :
-# evaluation : evaluation d'une solution
-# recherche locale iterative : optimisation par recherche locale
-# algorithme genetique : optimisation avec "population" de solutions
-# construction initiale seule : permet de visualiser l'etape preliminaire de construction
-# generation automatique d'instances : generer des instances de problemes variees

Le fonctionnement met en jeu les classes suivantes :
- SolutionObject : contient une solution de probleme
- LocalSearch : contient la procedure d'optimisation par recherche locale
- GeneticMethod : contient la procedure d'optimisation par gestion d'une population de solutions

Deux fichiers sont necessaires en entree, le fichier de configuration (sauf si surcharge par programme)
et le fichier d'instance. Deux fichiers sont systematiquement produits en sortie,
le fichier de sortie, solution du probleme, et le fichier devaluation statistique en format 
ligne/colonne fournissant l'evaluation de la solution via les criteres et objectifs du probleme.

Un calcul d'optimisation ou d'evaluation, tel que lance via la methode "calcul" de la classe principale <Application>,
ou directement via les appels des methodes d'optimisation des classes LocalSearch ou GeneticMethod 
comporte les etapes principales suivantes :
-# lecture du fichier de configuration des parametres d'execution (nom par defaut config.cfg)
-# lecture de l'instance/solution du probleme (nom par defaut input.svg)
-# evaluation de la solution/instance initiale chargee
-# initialisation des algorithmes d'optimisation a partir de la solution initiale
-# phase d'optimisation
-# sauvegarde de la solution du probleme (nom par defaut output.svg)
-# ecriture des criteres d'evaluation dans le fichier de statistiques en sortie (nom par defaut output.stats)

Remarque : Toute sortie peut etre utilisee en entree pour evaluation ou egalement servir de solution initiale (ou d'instance) 
d'une nouvelle phase d'optimisation. Cela est utile pour appliquer des procedures de post-optimisation
visant a affiner les solutions obtenues.

Les pages suivantes abordent les points suivants :
-# Installation
-# Lancement d'un test
-# Parametres de configuration
-# Tests de validation
-# Cross-compilation
-# Evolution des versions

\page page2 Installation
************************
- Decompresser le dossier <application_template>.zip.

- Principaux repertoires de l'application (dossier <application>)

    - ./bin : contient l'executable et les librairies .lib et dll
    - ./lib : contient la librairie .lib (copie du .lib du .\bin)
    - ./src : sources .ccp (inclu le main)
    - ./include : fichier d'entetes .h
    - ./test : dossiers de tests, permet de lancer des calculs d'optimisation sur differents jeux de tests a partir 
de fichiers de commandes systemes .bat, ou scripts unix.

- Deux fichiers projets Qt .pro fournis

    - ./lib/lib.pro : permet de generer la librairie sous forme de dll (dynamic link) ou lib (static link)
    - ./test/test.pro : programme de test executable main.c avec liaison avec la librairie

- Installation des bibliotheques accessoires

    - Boost 1.55 : ne necessite pas de dll, seuls les sources via les .h sont necessaires pour
certaines fonctions geometriques telles que les intersections, unions, et aires de polygones.

\page page3 Lancement d'un test
*******************************
- Via la ligne de commande

Se positionner par exemple dans le repertoire ./test/test_exemple.
Eventuellement "nettoyer" les repertoires avec "clean.bat" (suppresion des <output> et <.stats>).
Double click sur l'icone test.bat pour lancer un calcul d'optimisation.

Note : les fichiers de commandes .bat permettent de lancer l'application
en executant la ligne de commande appropriee du type :

../../application.exe [<input> [<output> [<output.stats> [<config.cfg>]]]]

L'argument entre crochets [] est optionnel, par defaut les noms de fichiers consideres sont les suivants :
"input.data", "output.data", "output.stats", "config.cfg".

- Via appel par programme

Le programme main.c dans .\src contient deux exemples d'utilisation de la librairie par appel de la fonction 
Application::calcul().

Deux classes exportees sont accessibles pour configuer et lancer un calcul d'optimisation.
La classe ConfigParams : contient les parametres de configuration correspondant 
aux parametres d'un fichier de configuration.
La classe Application : contient la fonction <calcul>.

Le fichier main.cpp fournit un exemple d'appel avec initialisation des parametres de configuration dans le main.

\page pageParam Parametres de configuration
*******************************************

Cette section presente les parametres de configuration par sections, avec une valeur par defaut.

[global_param]

- Choix du mode de fonctionnement 0:evaluation, 1:local search, 
2:genetic algorithm, 3:construction initiale seule,
4:generation automatique d'instances
    - functionModeChoice = 2

- Affichage trace d'exection statistique
    - traceActive = false
- Trace d'exection statistique avec la meilleure solution rencontree, ou la solution courante
    - traceReportBest = true
- Trace d'exection avec sauvegarde de la solution courante
    - traceSaveSolutionFile = false

- Ponderations de la fonction objectif W1, ..., W3, f = W1 * f1 + W2 * f2 + W3 * f3
    - weight_f1 = 0.01
    - weight_f2 = 0.001
    - weight_f3 = 0.0001

[local_search]

- Faux s'il s'agit de partir de l'input comme solution pre-construite, 
Vrai si on construit a partir d'une initialisation aleatoire
    - constructFromScratchParam = true

- Type de la recherche locale, 0: marche aleatoire, 1: LS first improvement, 2: LS best improvement
    - localSearchType = 1

- Parametres de la recherche locale
    - neighborhoodSize = 1000
    - nbOfConstructAndRepairs = 10
    - nbOfInternalConstructs = 100
    - nbOfInternalRepairs = 20000

[genetic_method]

- Vrai si algorithme memetique, Faux si algorithme genetique simple
    - memeticAlgorithm = true

- Taille population
    - populationSize = 10

- Nombre maximum de generations
    - generationNumber = 10

- Algo memetic (parametres recherche locale surcharges)
    - MAneighborhoodSize = 100
    - MAnbOfInternalConstructs = 10
    - MAnbOfInternalRepairs = 2000

[instance_generator]

- Nombre d'instances generees
    - nInstances = 10

\page pageCross Cross-compilation de windows vers ARM V6 (raspberry pi)
**********************************************************************
- compilation standard avec IDE QT : mettre shadow build au niveau externe immediat :
	- application_template/build-lib-Desktop-Release
	- application_template/build-test-Desktop-Release
- chaine de cross-compilation Windows vers Raspberry Pi
	- Installer le cross-compilateur SysGCC (arm-linux-gnueabihf) sous Windows
	- Telecharger de http://gnutoolchains.com/raspberry/
	- Compiler Qt sous Windows pour raspberry pi : qmake, QtCore et QtXml.
Ces trois composants sont suffisants pour la compilation et cross compilation a la fois
sous raspberry et sous windows (cross-compilation). L'utilitaire qmake compile sur chaque platforme,
permet la generation des Makefile appropries a partir des projets Qt d'extension .pro.
- generation d'une version de Qt precompilee pour cross-compilation de windows vers raspberry pi :
	- qt-everywhere-opensource-src-4.8.4_rasp
- directives et option de compilation :
	- Configuration QT avant compilation (generation des Makefile) :
configure -release -static -platform win32-g++ -xplatform linux-arm-gnueabi-g++ -no-3dnow -opengl desktop -nomake examples -nomake tests -no-webkit
	- Mettre -no-qmake en cas de reconfigurations successives
	- Modification Makefile avant compilation (selon module corelib, xml) : -DQT_ARCH_ARMV6
	- Lancement make : mingw32-make
	- Pour compilation croisee mettre la variable d'environnement QMAKESPEC a la valeur linux-arm-gnueabi-g++

- tutoriels (utiles pour compilation de Qt sous raspberry pi):
	- tutoriel installation QT 5 sous raspberry : 
http://qt-project.org/wiki/Native_Build_of_Qt5_on_a_Raspberry_Pi
	- tutoriel cross-compilation Qt vers raspberry (linux-linux) : 
https://debian-facile.org/topic-8425-comment-cross-compiler-qt-pour-du-arm-page-1.html

- modification des fichiers projets lib.pro, test.pro, pour qmake et cross-compilation

	- pour la cross-compilation de Windows vers Linux Raspberry pi, mettre
la variable d'environnement QMAKESPEC a linux-arm-gnueabi-g++, choix du Qt prealablement
cross-compile pour Raspberry Pi et choix compilateur arm-linux-gnueabihf-g++.exe
(chaine cross-compilation SysGCC)
	- permet de compiler directement sur Raspberry Pi (qmake, make) faire CONFIG += arm
	- permet de compiler avec CGAL (uniquement avec QMAKESPEC en win32-msvc2010), 
faire CONFIG += cgal

- compilation croisee par ligne de commande avec console windows

	- pour lancer et initialiser une console : creer un raccourci de CommandPrompt avec 
Cible=%COMSPEC% /k "C:\Qt\qt..._rasp\bin\qtvars.bat vsvars" et 
faire demarrer dans application/lib par exemple
(le script qtvars.bat positionne QMAKESPEC=linux-arm-gnueabi-g++ et la variable Path)
	- aller dans /lib
	- supprimer .o et Makefile
	- taper qmake (celui du dossier QT rasp est execute) : genere le Makefile a partir du lib.pro
	- taper mingw32-make : compile et genere la librairie liblibApplication.so.1.0.0
	- copier liblibApplication.so.1.0.0 dans bin/liblibApplication.so manuellement 
a cause d'une erreur Makefile (commande "mv")
	- pour le programme appelant /test/main.c aller dans /test
	- supprimer .o et Makefile
	- taper qmake
	- taper mingw32-make

L'executable "application" est genere dans le repertoire /bin.

Pour executer sur la machine cible, il suffit alors de transferer l'executable "application" et 
la librairie liblibApplication.so sur le raspberry pi, dans les repertoires appropries. 
Verifier les dependances avec la commande "ldd application". Tenir compte des extensions ".so", "so.1". 
Verifier la presence des modules Qt (QtCore, QtXml) sur le rapberry.

\page page6 Tests de validation et de verification des fonctionnalites
**********************************************************************
Le programme Application est teste et valide sur un ensemble de jeux de tests, appeles benchmarks,
situes dans le repertoire ./test.

Chaque sous-dossier comporte des instances (issues de cas reels ou generees automatiquement)
sur lesquelles sont appliques des schemas de resolution specifiques suivant la configuration
des parametres choisis. Rappelons que l'application prend en entree un fichier specifiant la donnee du probleme,
ou instance, et un fichier de configuration des parametres d'execution appele par defaut
"config.cfg" (\ref pageParam). En sortie il genere une solution et un fichier de statistiques "output.stats"
contenant les criteres d'evaluation de la solution produite. Noter qu'une sortie peut egalement etre utilisee en entree 
pour evaluation ou comme point de depart d'une nouvelle execution.

Un fichier de configuration en mode evaluation "config_evaluate.cfg" est egalement present.
Il definit le mode d'execution en evaluation seule, sans optimisation. L'entree qui est une solution
est seulement evaluee suivant les criteres du probleme. Elle est reproduite en sortie
avec les valeurs statistiques d'evaluation. La seule difference entre le fichier d'optimisation
"config.cfg" et le fichier d'evaluation "config_evaluate.cfg" se situe dans la variable
de configuration "functionModeChoice". Dans le premier cas, nous avons :
- functionModeChoice = 2, pour le mode d'optimlisation "algo genetique"
et dans le deuxieme cas :
- functionModeChoice = 0, pour le mode evaluation.

Les variations des parametres de configuration pour les differents tests de validation
sont minimes par rapport a la configuration type du repertoire "benchmark".

Pour lancer une execution complete automatisee de tous les tests, il faut :
- Nettoyer le repertoire avec la commande "clean.bat" et generer les jeux d'instances
pour les repertoires prefixes par "g_" qui signifie que le test est base sur des instances
generees automatiquement. Pour cela, executer la commande "generate.bat" basee
sur une configuration en mode "generation" avec functionModeChoice = 4.
Cette commande genere des jeux d'instances aleatoires en se basant sur l'entree SVG. 

- Executer la commande "./test/test_all.bat" l'ensemble des tests.

Les tests de validation se decomposent en deux groupes, les tests avec generation d'instance automatique et les tests
avec instances issues de cas reels ou instances specifiques. La liste des tests
de validation est la suivante :

- tests avec generation automatique (prefixe "g_") :
	- g_test_exemple

- tests cas reels ou specifiques (base "benchmark"):
	- test_exemple

Apres execution, les solutions "output.data" et les fichiers statistiques d'evaluation "output.stats" peuvent
etre consultes dans les repertoires respectifs. Un fichier Excel "result_analysis.xlsx"
fournit un schema type d'analyse des solutions et permet la production de 
representation graphique.

Nous detaillons les particularites de chaque application :

- g_test_exemple

Il s'agit de tester les fonctions de ...

- test_exemple

Test issu de cas reels resolu en moins de xx secondes sur un PC Dual Core. Utilise les parametres :

	- param1 =
	- param2 =

*/